<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Live Bus Tracking</title>
    <!-- Adicionando Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
          integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
          crossorigin=""/>
    <style>
        /* Estilos existentes (mantidos) */
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        h1 {
            color: #333;
            text-align: center;
        }
        .stats {
            display: flex;
            justify-content: space-around;
            margin-bottom: 20px;
            padding: 10px;
            background-color: #f0f0f0;
            border-radius: 4px;
        }
        .stat-item {
            text-align: center;
        }
        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #2c3e50;
        }
        .stat-label {
            font-size: 14px;
            color: #7f8c8d;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }
        th, td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }
        th {
            background-color: #f2f2f2;
            position: sticky;
            top: 0;
            cursor: pointer;
        }
        tr:hover {
            background-color: #f5f5f5;
        }
        .status-connected {
            color: green;
            font-weight: bold;
        }
        .status-disconnected {
            color: red;
            font-weight: bold;
        }
        .search-container {
            margin-bottom: 20px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        .search-group {
            display: flex;
            flex-direction: column;
            flex: 1;
            min-width: 200px;
        }
        .search-label {
            font-size: 14px;
            margin-bottom: 5px;
            color: #555;
            font-weight: bold;
        }
        .search-input {
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        #search-map-btn {
            padding: 10px 15px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            align-self: flex-end;
            margin-top: 23px;
            height: 40px;
        }
        #search-map-btn:hover {
            background-color: #45a049;
        }
        .last-update {
            text-align: right;
            font-size: 12px;
            color: #7f8c8d;
            margin-bottom: 10px;
        }
        .pagination {
            display: flex;
            justify-content: center;
            margin: 20px 0;
        }
        .pagination button {
            margin: 0 5px;
            padding: 5px 10px;
            border: 1px solid #ddd;
            background-color: #f8f8f8;
            cursor: pointer;
        }
        .pagination button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .pagination button.active {
            background-color: #4CAF50;
            color: white;
        }
        /* Estilos para o mapa */
        #map-container {
            margin-top: 30px;
            border-top: 1px solid #ddd;
            padding-top: 20px;
            display: none; /* Inicialmente oculto */
        }
        #map-title {
            text-align: center;
            margin-bottom: 10px;
            font-weight: bold;
            color: #2c3e50;
        }
        #map {
            height: 500px;
            width: 100%;
            border-radius: 8px;
            z-index: 1;
        }
        .map-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            flex-wrap: wrap;
            gap: 10px;
        }
        .map-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        .map-toggle {
            background-color: #4CAF50;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 4px;
            cursor: pointer;
        }
        .show-all-btn {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 4px;
            cursor: pointer;
        }
        .show-all-btn:hover {
            background-color: #2980b9;
        }
        .bus-marker {
            background-color: #2c3e50;
            border: 2px solid white;
            border-radius: 50%;
            width: 12px;
            height: 12px;
        }
        .bus-marker-line {
            position: absolute;
            bottom: -5px;
            right: -5px;
            background-color: #e74c3c;
            color: white;
            border-radius: 50%;
            width: 18px;
            height: 18px;
            font-size: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
        }
        .no-results {
            text-align: center;
            padding: 20px;
            color: #7f8c8d;
            font-style: italic;
        }
        .map-info {
            font-size: 14px;
            color: #7f8c8d;
        }
        .clear-filters {
            background-color: #e74c3c;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 4px;
            cursor: pointer;
            margin-top: 10px;
        }
        .clear-filters:hover {
            background-color: #c0392b;
        }
        .address-search {
            display: flex;
            margin-bottom: 10px;
            gap: 10px;
            position: relative;
        }
        .address-search input {
            flex: 1;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        .address-search button {
            padding: 10px 15px;
            background-color: #9b59b6;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        .address-search button:hover {
            background-color: #8e44ad;
        }
        .autocomplete-suggestions {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 1px solid #ddd;
            border-top: none;
            border-radius: 0 0 4px 4px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 1000;
            display: none;
        }
        .autocomplete-suggestion {
            padding: 10px;
            cursor: pointer;
            border-bottom: 1px solid #eee;
        }
        .autocomplete-suggestion:hover {
            background-color: #f0f0f0;
        }
        .autocomplete-suggestion:last-child {
            border-bottom: none;
        }

        /* Novos estilos para controles de itinerário */
        .itinerary-route {
            stroke-width: 4;
            stroke-opacity: 0.8;
        }

        .itinerary-route-ida {
            stroke: #007bff; /* Azul para ida */
        }

        .itinerary-route-volta {
            stroke: #ff0000; /* Vermelho sólido para volta */
        }
        .itinerary-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
            flex-wrap: wrap;
            align-items: center;
        }
        .itinerary-select {
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            min-width: 120px;
        }
        .itinerary-btn {
            padding: 8px 15px;
            background-color: #9b59b6;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        .itinerary-btn:hover {
            background-color: #8e44ad;
        }
        .itinerary-btn.active {
            background-color: #7d3c98;
        }
        .itinerary-info {
            font-size: 14px;
            color: #7f8c8d;
            margin-left: 10px;
        }

        @media (max-width: 768px) {
            .map-controls {
                flex-direction: column;
                align-items: flex-start;
            }
            .search-group {
                min-width: 100%;
            }
            .address-search {
                flex-direction: column;
            }
            .itinerary-controls {
                flex-direction: column;
                align-items: flex-start;
            }
        }
    </style>
</head>
<body>
<div class="container">
    <h1>Live Bus Tracking</h1>

    <div class="stats">
        <div class="stat-item">
            <div class="stat-value" id="total-buses">0</div>
            <div class="stat-label">Ônibus Em Operação</div>
        </div>
        <div class="stat-item">
            <div class="stat-value" id="visible-buses">0</div>
            <div class="stat-label">Exibindo</div>
        </div>
        <div class="stat-item">
            <div class="stat-value" id="connection-status">Desconectado</div>
            <div class="stat-label">Status Conexão</div>
        </div>
    </div>

    <div class="search-container">
        <div class="search-group">
            <label for="search-line" class="search-label">Filtrar por Linha:</label>
            <input type="text" id="search-line" class="search-input" placeholder="Ex: 123, 456...">
        </div>
        <div class="search-group">
            <label for="search-order" class="search-label">Filtrar por Ordem:</label>
            <input type="text" id="search-order" class="search-input" placeholder="Ex: 1001, 1002...">
        </div>
        <button id="search-map-btn">Buscar e Mostrar Mapa</button>
    </div>

    <button id="clear-filters" class="clear-filters">Limpar Filtros</button>

    <div class="last-update" id="last-update-time"></div>

    <div class="pagination">
        <button id="prev-page">Anterior</button>
        <span id="page-info">Página 1 de 1</span>
        <button id="next-page">Próxima</button>
    </div>

    <table id="buses-table">
        <thead>
        <tr>
            <th onclick="sortTable(0)">Ordem</th>
            <th onclick="sortTable(1)">Linha</th>
            <th onclick="sortTable(2)">Latitude</th>
            <th onclick="sortTable(3)">Longitude</th>
            <th onclick="sortTable(4)">Velocidade (km/h)</th>
            <th onclick="sortTable(5)">Última Atualização</th>
        </tr>
        </thead>
        <tbody id="buses-body">
        <!-- Os dados serão inseridos aqui via JavaScript -->
        </tbody>
    </table>

    <div class="pagination">
        <button id="prev-page-bottom">Anterior</button>
        <span id="page-info-bottom">Página 1 de 1</span>
        <button id="next-page-bottom">Próxima</button>
    </div>

    <!-- Container para o mapa -->
    <div id="map-container">
        <div id="map-title">Visualização dos Ônibus no Mapa</div>

        <div class="address-search">
            <input type="text" id="search-address" placeholder="Buscar endereço (rua, avenida, bairro, cidade...)">
            <div id="autocomplete-suggestions" class="autocomplete-suggestions"></div>
            <button id="search-address-btn">Buscar Endereço</button>
        </div>

        <!-- Controles para itinerários -->
        <div class="itinerary-controls">
            <label for="itinerary-direction-select">Direção:</label>
            <select id="itinerary-direction-select" class="itinerary-select">
                <option value="0">Volta</option>
                <option value="1">Ida</option>
                <option value="both">Ambas</option>
            </select>

            <button id="show-itinerary-btn" class="itinerary-btn">Mostrar Itinerário da Linha Filtrada</button>
            <button id="hide-itinerary-btn" class="itinerary-btn">Ocultar Itinerário</button>

            <span id="itinerary-info" class="itinerary-info"></span>
        </div>

        <div class="map-controls">
            <div class="map-buttons">
                <button id="toggle-map" class="map-toggle">Ocultar Mapa</button>
                <button id="show-all-btn" class="show-all-btn">Mostrar Todos no Mapa</button>
            </div>
            <span id="map-buses-count" class="map-info">0 ônibus no mapa</span>
        </div>
        <div id="map"></div>
    </div>
</div>

<!-- Adicionando Leaflet JS -->
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
        integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
        crossorigin=""></script>

<script>
    let allBusesData = [];
    let currentUpdateBusesData = []; // Dados da atualização atual (todos os batches)
    let filteredBusesData = [];
    let currentPage = 1;
    const itemsPerPage = 50;
    let currentSortColumn = -1;
    let sortDirection = 1;

    // Variáveis para controlar a atualização atual
    let currentBatchNumber = 0;
    let currentTotalBatches = 0;
    let currentUpdateId = 0;

    // Variáveis para o mapa
    let map = null;
    let busMarkers = {};
    let showMap = false;
    let mapInitialized = false;
    let showingAllBuses = false;
    let currentMapView = null; // Para armazenar a visualização atual do mapa
    let addressMarker = null; // Marcador para o endereço pesquisado
    let autocompleteTimeout = null;

    // Variáveis para itinerários
    let itineraryData = null; // Armazenará todos os dados de itinerário
    let currentItineraryLines = {}; // Armazenará as linhas de itinerário atualmente exibidas

    // Inicializar o mapa
    const initMap = () => {
        // Coordenadas padrão (centro da cidade, por exemplo)
        const defaultCenter = [-23.5505, -46.6333]; // São Paulo

        map = L.map('map').setView(defaultCenter, 12);

        // Adicionar camada do OpenStreetMap
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
        }).addTo(map);

        mapInitialized = true;

        // Salvar a visualização inicial
        saveMapView();
    };

    // Salvar a visualização atual do mapa
    const saveMapView = () => {
        if (!mapInitialized) return;
        currentMapView = {
            center: map.getCenter(),
            zoom: map.getZoom()
        };
    };

    // Restaurar a visualização salva do mapa
    const restoreMapView = () => {
        if (!mapInitialized || !currentMapView) return;
        map.setView(currentMapView.center, currentMapView.zoom);
    };

    // Função para formatar o endereço extraindo apenas as partes relevantes
const formatAddress = (displayName) => {
    // Dividir o endereço por vírgulas
    const parts = displayName.split(',');

    // Manter apenas os primeiros elementos (rua, bairro, cidade)
    if (parts.length >= 3) {
        // Juntar os três primeiros componentes
        return `${parts[0].trim()}, ${parts[1].trim()}, ${parts[2].trim()}`;
    }

    // Se não tiver pelo menos 3 partes, retornar o original
    return displayName;
};


   // Buscar sugestões de endereço usando Nominatim com filtro para Rio de Janeiro
const fetchAddressSuggestions = async (query) => {
    if (!query || query.length < 3) {
        document.getElementById('autocomplete-suggestions').style.display = 'none';
        return;
    }

    try {
        // Parâmetros para restringir a busca ao Rio de Janeiro
        const viewbox = '-43.8,-23.1,-43.1,-22.8'; // Coordenadas aproximadas do RJ (ajustadas)
        const bounded = 1; // Forçar resultados dentro da área
        const countrycodes = 'br'; // Código do país (Brasil)

        const response = await fetch(
            `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}` +
            `&limit=5&countrycodes=${countrycodes}&bounded=${bounded}&viewbox=${viewbox}`
        );
        const data = await response.json();

        const suggestionsContainer = document.getElementById('autocomplete-suggestions');
        suggestionsContainer.innerHTML = '';

        if (data && data.length > 0) {
            data.forEach(item => {
                const suggestion = document.createElement('div');
                suggestion.className = 'autocomplete-suggestion';

                // Formatar o endereço para exibição (apenas partes relevantes)
                const displayText = formatAddress(item.display_name);
                suggestion.textContent = displayText;

                // Armazenar o endereço completo em um atributo de dados
                suggestion.setAttribute('data-full-address', item.display_name);

                suggestion.addEventListener('click', () => {
                    // Usar o endereço completo armazenado
                    const fullAddress = suggestion.getAttribute('data-full-address');
                    document.getElementById('search-address').value = displayText;
                    suggestionsContainer.style.display = 'none';
                    searchAddress(fullAddress, item.lat, item.lon);
                });

                suggestionsContainer.appendChild(suggestion);
            });
            suggestionsContainer.style.display = 'block';
        } else {
            suggestionsContainer.style.display = 'none';

            // Mostrar mensagem indicando que não foram encontrados resultados no RJ
            const noResultsMsg = document.createElement('div');
            noResultsMsg.className = 'autocomplete-suggestion';
            noResultsMsg.textContent = 'Nenhum endereço encontrado no Rio de Janeiro';
            noResultsMsg.style.color = '#999';
            noResultsMsg.style.cursor = 'default';
            suggestionsContainer.appendChild(noResultsMsg);
            suggestionsContainer.style.display = 'block';
        }
    } catch (error) {
        console.error('Erro ao buscar sugestões:', error);
        document.getElementById('autocomplete-suggestions').style.display = 'none';
    }
};

    // Buscar endereço usando Nominatim (OpenStreetMap)
    const searchAddress = async (address = null, lat = null, lon = null) => {
    const addressValue = address || document.getElementById('search-address').value.trim();
    if (!addressValue) return;

    try {
        // Mostrar indicador de carregamento
        document.getElementById('search-address-btn').textContent = 'Buscando...';

        let result;
        if (lat && lon) {
            // Se já temos as coordenadas (vindo do autocomplete)
            result = { lat: parseFloat(lat), lon: parseFloat(lon), display_name: addressValue };
        } else {
            // Fazer uma nova busca com filtro para RJ
            const viewbox = '-43.8,-23.1,-43.1,-22.8';
            const bounded = 1;
            const countrycodes = 'br';

            const response = await fetch(
                `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(addressValue)}` +
                `&limit=1&countrycodes=${countrycodes}&bounded=${bounded}&viewbox=${viewbox}`
            );
            const data = await response.json();

            if (data && data.length > 0) {
                result = data[0];
            } else {
                alert('Endereço não encontrado no Rio de Janeiro. Tente ser mais específico ou use um endereço do RJ.');
                return;
            }
        }

        const latVal = parseFloat(result.lat);
        const lonVal = parseFloat(result.lon);

        // Remover marcador anterior se existir
        if (addressMarker) {
            map.removeLayer(addressMarker);
        }

        // Adicionar marcador para o endereço encontrado
        addressMarker = L.marker([latVal, lonVal])
            .addTo(map)
            .bindPopup(`<strong>Endereço:</strong><br>${result.display_name}`)
            .openPopup();

        // Centralizar o mapa no endereço com zoom adequado
        map.setView([latVal, lonVal], 15);

        // Salvar a visualização
        saveMapView();

    } catch (error) {
        console.error('Erro ao buscar endereço:', error);
        alert('Erro ao buscar endereço. Tente novamente.');
    } finally {
        document.getElementById('search-address-btn').textContent = 'Buscar Endereço';
        document.getElementById('autocomplete-suggestions').style.display = 'none';
    }
};

    // Atualizar marcadores no mapa
    const updateMapMarkers = (showAll = false) => {
        if (!mapInitialized) return;

        // Salvar a visualização atual antes de atualizar
        const currentCenter = map.getCenter();
        const currentZoom = map.getZoom();
        const userInteracting = map._moving; // Verificar se o usuário está interagindo com o mapa

        // Limpar marcadores antigos (apenas ônibus, mantém o marcador de endereço)
        Object.values(busMarkers).forEach(marker => {
            map.removeLayer(marker);
        });
        busMarkers = {};

        // Determinar quais dados usar
        const dataToShow = showAll ? allBusesData : filteredBusesData;
        showingAllBuses = showAll;

        // Atualizar texto do botão
        document.getElementById('show-all-btn').textContent =
            showAll ? 'Voltar para Busca' : 'Mostrar Todos no Mapa';

        // Verificar se há dados para exibir no mapa
        if (dataToShow.length === 0) {
            document.getElementById('map-buses-count').textContent = 'Nenhum ônibus para exibir';
            return;
        }

        // Adicionar novos marcadores apenas para os ônibus com coordenadas
        const busesWithCoords = dataToShow.filter(bus => bus.latitude && bus.longitude);

        busesWithCoords.forEach(bus => {
            // Criar marcador personalizado
            const markerIcon = L.divIcon({
                className: 'bus-marker-icon',
                html: `
                    <div class="bus-marker">
                        <div class="bus-marker-line">${bus.linha || ''}</div>
                    </div>
                `,
                iconSize: [24, 24],
                iconAnchor: [12, 12]
            });

            const marker = L.marker([bus.latitude, bus.longitude], {icon: markerIcon})
                .addTo(map);

            // Adicionar popup com informações do ônibus
            marker.bindPopup(`
                <strong>Ônibus ${bus.ordem || 'N/A'}</strong><br>
                Linha: ${bus.linha || 'N/A'}<br>
                Velocidade: ${bus.velocidade || '0'} km/h<br>
                Última atualização: ${bus.datahoraservidor ? new Date(bus.datahoraservidor).toLocaleString() : 'N/A'}
            `);

            busMarkers[bus.ordem] = marker;
        });

        // Atualizar contador no mapa
        const totalBuses = Object.keys(busMarkers).length;
        const totalText = showAll ?
            `${totalBuses} de ${allBusesData.length} ônibus no mapa (todos)` :
            `${totalBuses} ônibus no mapa`;

        document.getElementById('map-buses-count').textContent = totalText;

        // Manter a visualização atual se o usuário estava interagindo com o mapa
        // Apenas ajustar a visualização se for a primeira vez ou se o usuário não estava interagindo
        if (!userInteracting && totalBuses > 0) {
            const group = new L.featureGroup(Object.values(busMarkers));

            // Se é a primeira vez carregando o mapa ou não há visualização salva
            if (!currentMapView || currentZoom === 12) {
                map.fitBounds(group.getBounds().pad(0.1));
            } else {
                // Restaurar a visualização anterior
                map.setView(currentCenter, currentZoom);
            }
        }

        // Salvar a visualização atual para futuras atualizações
        saveMapView();
    };

    // Mostrar ou esconder o mapa
    const toggleMapVisibility = (visible) => {
        const mapContainer = document.getElementById('map-container');
        const toggleButton = document.getElementById('toggle-map');

        if (visible) {
            // Inicializar o mapa se não foi inicializado ainda
            if (!mapInitialized) {
                initMap();
            }

            mapContainer.style.display = 'block';
            toggleButton.textContent = 'Ocultar Mapa';

            // Atualizar marcadores no mapa
            updateMapMarkers(showingAllBuses);

            // Redimensionar o mapa para garantir que ele se renderize corretamente
            setTimeout(() => {
                if (mapInitialized) map.invalidateSize();
            }, 100);
        } else {
            mapContainer.style.display = 'none';
            toggleButton.textContent = 'Mostrar Mapa';
        }

        showMap = visible;
    };

    // Carregar dados de itinerário da API
    const loadItineraryData = async () => {
        try {
            console.log('Carregando dados de itinerário...');
            const response = await fetch('https://pgeo3.rio.rj.gov.br/arcgis/rest/services/Hosted/Itiner%C3%A1rios_da_rede_de_transporte_p%C3%BAblico_por_%C3%B4nibus_(SPPO)/FeatureServer/1/query?outFields=*&where=1%3D1&f=geojson');
            itineraryData = await response.json();
            console.log('Dados de itinerário carregados:', itineraryData);

            document.getElementById('itinerary-info').textContent = 'Dados de itinerário carregados';
        } catch (error) {
            console.error('Erro ao carregar dados de itinerário:', error);
            document.getElementById('itinerary-info').textContent = 'Erro ao carregar itinerários';
        }
    };

    // Preencher o seletor de linhas com as opções disponíveis
    const populateLineSelector = () => {
        if (!itineraryData || !itineraryData.features) return;

        const lineSelect = document.getElementById('itinerary-line-select');
        const lines = new Set();

        // Coletar todas as linhas únicas
        itineraryData.features.forEach(feature => {
            if (feature.properties && feature.properties.servico) {
                lines.add(feature.properties.servico);
            }
        });

        // Ordenar as linhas numericamente
        const sortedLines = Array.from(lines).sort((a, b) => parseInt(a) - parseInt(b));

        // Adicionar opções ao seletor
        sortedLines.forEach(line => {
            const option = document.createElement('option');
            option.value = line;
            option.textContent = line;
            lineSelect.appendChild(option);
        });

        document.getElementById('itinerary-info').textContent = `${sortedLines.length} linhas carregadas`;
    };

    // Obter a linha selecionada no filtro
    const getSelectedLineFromFilter = () => {
        return document.getElementById('search-line').value.trim();
    };

    // Mostrar itinerário no mapa
    const showItinerary = () => {
        const selectedLine = getSelectedLineFromFilter();
        const selectedDirection = document.getElementById('itinerary-direction-select').value;

        if (!selectedLine) {
            alert('Por favor, digite uma linha no filtro "Filtrar por Linha" primeiro.');
            return;
        }

        if (!itineraryData || !itineraryData.features) {
            alert('Dados de itinerário não carregados. Tente novamente em alguns instantes.');
            return;
        }

        // Limpar itinerários anteriores
        hideItinerary();

        // Filtrar features pela linha selecionada
        const lineFeatures = itineraryData.features.filter(feature =>
            feature.properties && feature.properties.servico === selectedLine
        );

        if (lineFeatures.length === 0) {
            document.getElementById('itinerary-info').textContent = 'Nenhum itinerário encontrado para esta linha';
            return;
        }

        // Filtrar por direção se necessário
        let featuresToShow = [];
        if (selectedDirection === 'both') {
            featuresToShow = lineFeatures;
        } else {
            const direction = parseInt(selectedDirection);
            featuresToShow = lineFeatures.filter(feature =>
                feature.properties && feature.properties.direcao === direction
            );
        }

        if (featuresToShow.length === 0) {
            const directionName = selectedDirection === '0' ? 'volta' : 'ida';
            document.getElementById('itinerary-info').textContent = `Nenhum itinerário de ${directionName} encontrado`;
            return;
        }

        // Adicionar cada itinerário ao mapa
        featuresToShow.forEach(feature => {
            if (feature.geometry && feature.geometry.coordinates) {
                // Converter coordenadas para o formato [lat, lng] que o Leaflet espera
                const latLngs = feature.geometry.coordinates.map(coord => [coord[1], coord[0]]);

                // Criar uma polilinha com estilos diferentes para ida e volta
                const color = feature.properties.direcao === 1 ? '#007bff' : '#ff0000'; // Azul para ida, Vermelho para volta
                const weight = feature.properties.direcao === 1 ? 4 : 4;
                const opacity = feature.properties.direcao === 1 ? 0.7 : 0.8;
                const dashArray = null; // Sólido para ambas as direções (remover o tracejado)

                const polyline = L.polyline(latLngs, {
                    color: color,
                    weight: weight,
                    opacity: opacity,
                    dashArray: dashArray
                }).addTo(map);

                // Adicionar popup com informações
                const directionName = feature.properties.direcao === 1 ? 'IDA' : 'VOLTA';
                polyline.bindPopup(`
                    <strong>Linha ${feature.properties.servico}</strong><br>
                    Direção: ${directionName}<br>
                    Destino: ${feature.properties.destino || 'N/A'}<br>
                    Consórcio: ${feature.properties.consorcio || 'N/A'}
                `);

                // Armazenar referência para remoção posterior
                const key = `${feature.properties.servico}_${feature.properties.direcao}`;
                if (!currentItineraryLines[key]) {
                    currentItineraryLines[key] = [];
                }
                currentItineraryLines[key].push(polyline);
            }
        });

        // Ajustar a visualização do mapa para mostrar todos os itinerários
        const bounds = new L.LatLngBounds();
        featuresToShow.forEach(feature => {
            if (feature.geometry && feature.geometry.coordinates) {
                feature.geometry.coordinates.forEach(coord => {
                    bounds.extend([coord[1], coord[0]]);
                });
            }
        });

        if (bounds.isValid()) {
            map.fitBounds(bounds.pad(0.1));
        }

        // Atualizar informação
        const directionText = selectedDirection === 'both' ? 'idas e voltas' :
                            (selectedDirection === '1' ? 'ida' : 'volta');
        document.getElementById('itinerary-info').textContent =
            `Itinerário(s) da linha ${selectedLine} (${directionText}) exibido(s)`;
    };

    // Ocultar itinerários do mapa
    const hideItinerary = () => {
        // Remover todas as polilinhas de itinerário
        Object.values(currentItineraryLines).forEach(lines => {
            lines.forEach(line => {
                map.removeLayer(line);
            });
        });
        currentItineraryLines = {};

        document.getElementById('itinerary-info').textContent = 'Itinerário oculto';
    };

    // Conectar ao WebSocket
    const connectWebSocket = () => {
        const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        const wsUrl = `${protocol}//${window.location.host}/gps-updates`;

        console.log('Conectando ao WebSocket:', wsUrl);
        const ws = new WebSocket(wsUrl);

        ws.onopen = () => {
            console.log('Conectado ao WebSocket');
            document.getElementById('connection-status').textContent = 'Conectado';
            document.getElementById('connection-status').className = 'status-connected';
            document.getElementById('last-update-time').textContent = 'Conectado - aguardando dados...';

            // Resetar dados da atualização atual
            currentUpdateBusesData = [];
            currentBatchNumber = 0;
            currentTotalBatches = 0;
            currentUpdateId++;
        };

        ws.onmessage = (event) => {
            try {
                const message = JSON.parse(event.data);
                console.log('Mensagem recebida:', message);

                // Verificar se é o formato com metadados
                if (message.batch && Array.isArray(message.batch)) {
                    const batchData = message.batch;
                    const batchNumber = message.batchNumber;
                    const totalBatches = message.totalBatches;

                    console.log(`Recebido batch ${batchNumber}/${totalBatches} com ${batchData.length} registros`);

                    // Se for uma nova atualização (batchNumber = 1), resetar os dados
                    if (batchNumber === 1) {
                        currentUpdateBusesData = [];
                        currentTotalBatches = totalBatches;
                        currentUpdateId++;
                        console.log(`Iniciando nova atualização #${currentUpdateId} com ${totalBatches} batches`);
                    }

                    // Acumular dados da atualização atual
                    currentUpdateBusesData = currentUpdateBusesData.concat(batchData);

                    // Se for o último batch desta atualização, processar os dados
                    if (batchNumber === totalBatches) {
                        console.log(`Último batch recebido. Total de ${currentUpdateBusesData.length} ônibus na atualização #${currentUpdateId}`);

                        // MANTER APENAS OS DADOS DA ÚLTIMA ATUALIZAÇÃO COMPLETA
                        allBusesData = [...currentUpdateBusesData];

                        // ATUALIZAR OS DADOS FILTRADOS com base nos filtros atuais
                        applyFilters();

                        // Atualizar interface
                        updateStats();
                        renderTable();

                        // Atualizar mapa apenas se estiver visível
                        if (showMap) {
                            updateMapMarkers(showingAllBuses);
                        }

                        document.getElementById('last-update-time').textContent =
                            `Última atualização: ${new Date().toLocaleTimeString()}`;
                    }

                } else if (Array.isArray(message)) {
                    console.log('Recebidos', message.length, 'registros (formato antigo)');
                    // Formato antigo: tratar como atualização completa
                    allBusesData = [...message];
                    applyFilters();
                    updateStats();
                    renderTable();

                    // Atualizar mapa apenas se estiver visível
                    if (showMap) {
                        updateMapMarkers(showingAllBuses);
                    }

                    document.getElementById('last-update-time').textContent =
                        `Última atualização: ${new Date().toLocaleTimeString()} `;
                } else {
                    console.error('Formato de mensagem desconhecido:', message);
                }

            } catch (error) {
                console.error('Erro ao processar dados:', error);
            }
        };

        ws.onclose = () => {
            console.log('Conexão WebSocket fechada');
            document.getElementById('connection-status').textContent = 'Desconectado';
            document.getElementById('connection-status').className = 'status-disconnected';
            document.getElementById('last-update-time').textContent = 'Desconectado - tentando reconectar...';

            setTimeout(connectWebSocket, 5000);
        };

        ws.onerror = (error) => {
            console.error('Erro WebSocket:', error);
            document.getElementById('connection-status').textContent = 'Erro';
            document.getElementById('connection-status').className = 'status-disconnected';
        };
    };

    // Aplicar filtros de linha e ordem
    const applyFilters = () => {
        const lineFilter = document.getElementById('search-line').value.toLowerCase();
        const orderFilter = document.getElementById('search-order').value.toLowerCase();

        if (!lineFilter && !orderFilter) {
            filteredBusesData = [...allBusesData];
        } else {
            filteredBusesData = allBusesData.filter(bus => {
                const lineMatch = !lineFilter || (bus.linha && bus.linha.toLowerCase().includes(lineFilter));
                const orderMatch = !orderFilter || (bus.ordem && bus.ordem.toLowerCase().includes(orderFilter));
                return lineMatch && orderMatch;
            });
        }
    };

    // Atualizar a tabela com os dados recebidos
    const renderTable = () => {
        const tableBody = document.getElementById('buses-body');

        if (filteredBusesData.length === 0) {
            tableBody.innerHTML = '<tr><td colspan="6" class="no-results">Nenhum ônibus encontrado</td></tr>';
            return;
        }

        const startIndex = (currentPage - 1) * itemsPerPage;
        const endIndex = Math.min(startIndex + itemsPerPage, filteredBusesData.length);
        const pageData = filteredBusesData.slice(startIndex, endIndex);

        let tableHtml = '';
        pageData.forEach(bus => {
            tableHtml += `
                <tr>
                    <td>${bus.ordem || 'N/A'}</td>
                    <td>${bus.linha || 'N/A'}</td>
                    <td>${bus.latitude ? bus.latitude.toFixed(6) : 'N/A'}</td>
                    <td>${bus.longitude ? bus.longitude.toFixed(6) : 'N/A'}</td>
                    <td>${bus.velocidade || '0'}</td>
                    <td>${bus.datahoraservidor ? new Date(bus.datahoraservidor).toLocaleString() : 'N/A'}</td>
                </tr>
            `;
        });

        tableBody.innerHTML = tableHtml;
        updatePagination();
    };

    // Atualizar estatísticas
    const updateStats = () => {
        document.getElementById('total-buses').textContent = allBusesData.length;
        document.getElementById('visible-buses').textContent = filteredBusesData.length;
    };

    // Atualizar controles de paginação
    const updatePagination = () => {
        const totalPages = Math.ceil(filteredBusesData.length / itemsPerPage);
        const pageInfo = `Página ${currentPage} de ${totalPages}`;

        document.getElementById('page-info').textContent = pageInfo;
        document.getElementById('page-info-bottom').textContent = pageInfo;

        document.getElementById('prev-page').disabled = currentPage === 1;
        document.getElementById('prev-page-bottom').disabled = currentPage === 1;
        document.getElementById('next-page').disabled = currentPage === totalPages || totalPages === 0;
        document.getElementById('next-page-bottom').disabled = currentPage === totalPages || totalPages === 0;
    };

    // Função para ordenar a tabela
    const sortTable = (columnIndex) => {
        if (currentSortColumn === columnIndex) {
            sortDirection *= -1;
        } else {
            currentSortColumn = columnIndex;
            sortDirection = 1;
        }

        filteredBusesData.sort((a, b) => {
            let valueA, valueB;

            switch (columnIndex) {
                case 0: valueA = a.ordem; valueB = b.ordem; break;
                case 1: valueA = a.linha; valueB = b.linha; break;
                case 2: valueA = a.latitude; valueB = b.latitude; break;
                case 3: valueA = a.longitude; valueB = b.longitude; break;
                case 4: valueA = a.velocidade; valueB = b.velocidade; break;
                case 5: valueA = new Date(a.datahoraservidor); valueB = new Date(b.datahoraservidor); break;
                default: return 0;
            }

            if (valueA < valueB) return -1 * sortDirection;
            if (valueA > valueB) return 1 * sortDirection;
            return 0;
        });

        currentPage = 1;
        renderTable();

        // Atualizar mapa apenas se estiver visível e não estiver mostrando todos
        if (showMap && !showingAllBuses) {
            updateMapMarkers(false);
        }
    };

    // Filtrar tabela com base nos critérios de busca
    const performSearch = () => {
        applyFilters();
        currentPage = 1;
        updateStats();
        renderTable();

        // Se estiver mostrando o mapa, atualizar com os resultados da busca
        if (showMap) {
            showingAllBuses = false;
            updateMapMarkers(false);
        }
    };

    // Limpar todos os filtros
    const clearFilters = () => {
        document.getElementById('search-line').value = '';
        document.getElementById('search-order').value = '';
        document.getElementById('search-address').value = '';

        // Remover marcador de endereço se existir
        if (addressMarker) {
            map.removeLayer(addressMarker);
            addressMarker = null;
        }

        // Esconder sugestões de autocomplete
        document.getElementById('autocomplete-suggestions').style.display = 'none';

        performSearch();
    };

    // Iniciar busca e mostrar mapa
    document.getElementById('search-map-btn').addEventListener('click', () => {
        performSearch();
        toggleMapVisibility(true);
    });

    // Permitir busca ao pressionar Enter em qualquer campo de filtro
    const searchInputs = document.querySelectorAll('.search-input');
    searchInputs.forEach(input => {
        input.addEventListener('keypress', (event) => {
            if (event.key === 'Enter') {
                performSearch();
                toggleMapVisibility(true);
            }
        });
    });

    // Atualizar filtros em tempo real (opcional)
    searchInputs.forEach(input => {
        input.addEventListener('input', () => {
            performSearch();
        });
    });

    // Buscar endereço ao clicar no botão
    document.getElementById('search-address-btn').addEventListener('click', () => {
        searchAddress();
    });

    // Buscar endereço ao pressionar Enter no campo de endereço
    document.getElementById('search-address').addEventListener('keypress', (event) => {
        if (event.key === 'Enter') {
            searchAddress();
        }
    });

    // Autocomplete para campo de endereço
    document.getElementById('search-address').addEventListener('input', (event) => {
        const query = event.target.value.trim();

        // Limpar timeout anterior
        if (autocompleteTimeout) {
            clearTimeout(autocompleteTimeout);
        }

        // Agendar nova busca após 300ms
        autocompleteTimeout = setTimeout(() => {
            fetchAddressSuggestions(query);
        }, 300);
    });

    // Esconder sugestões ao clicar fora
    document.addEventListener('click', (event) => {
        const suggestions = document.getElementById('autocomplete-suggestions');
        const addressInput = document.getElementById('search-address');

        if (event.target !== addressInput && !suggestions.contains(event.target)) {
            suggestions.style.display = 'none';
        }
    });

    // Limpar filtros
    document.getElementById('clear-filters').addEventListener('click', clearFilters);

    // Mostrar todos os ônibus no mapa
    document.getElementById('show-all-btn').addEventListener('click', () => {
        if (showingAllBuses) {
            // Se já está mostrando todos, voltar para a visualização de busca
            showingAllBuses = false;
            updateMapMarkers(false);
        } else {
            // Mostrar todos os ônibus no mapa
            showingAllBuses = true;
            updateMapMarkers(true);
        }
    });

    // Navegação de páginas
    document.getElementById('next-page').addEventListener('click', () => {
        const totalPages = Math.ceil(filteredBusesData.length / itemsPerPage);
        if (currentPage < totalPages) {
            currentPage++;
            renderTable();
        }
    });

    document.getElementById('prev-page').addEventListener('click', () => {
        if (currentPage > 1) {
            currentPage--;
            renderTable();
        }
    });

    document.getElementById('next-page-bottom').addEventListener('click', () => {
        const totalPages = Math.ceil(filteredBusesData.length / itemsPerPage);
        if (currentPage < totalPages) {
            currentPage++;
            renderTable();
        }
    });

    document.getElementById('prev-page-bottom').addEventListener('click', () => {
        if (currentPage > 1) {
            currentPage--;
            renderTable();
        }
    });

    // Alternar visibilidade do mapa
    document.getElementById('toggle-map').addEventListener('click', () => {
        toggleMapVisibility(!showMap);
    });

    // Mostrar itinerário
    document.getElementById('show-itinerary-btn').addEventListener('click', showItinerary);

    // Ocultar itinerário
    document.getElementById('hide-itinerary-btn').addEventListener('click', hideItinerary);

    // Iniciar conexão quando a página carregar
    window.onload = function() {
        connectWebSocket();
        loadItineraryData(); // Carregar dados de itinerário
    };
</script>
</body>
</html>